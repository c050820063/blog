---
title: post title with whitespace
date: 2020-05-11 10:11:50
tags:
---

# 正则表达式语法
## 捕获分组与非捕获分组（ ）
- 捕获分组（x） 匹配 x 并且捕获匹配项
例如：/(foo)/ 匹配且捕获 "foo bar" 中的 "foo"。被匹配的子字符串可以通过 元素[n] 中找到，或 RegExp 对象的属性 $n 中找到
``` bash
"foo bar".match(/(foo)\s+bar/)
// ["foo bar", "foo"]
```

- 非捕获分组(?:x) 匹配 x 不会捕获匹配项。匹配项不能够从结果再次访问
``` bash
"foo bar".match(/(?:foo)\s+bar/)
// ["foo bar"]
```

## 贪婪与非贪婪模式
默认使用贪婪模式 尽可能多的匹配
在重复量词后面加一个?，代表使用非贪婪模式，尽可能短的匹配
``` bash
//默认贪婪模式（尽可能匹配多）
"1234567".match(/\d{2,5}/)
[12345]
// 非贪婪模式
"1234567".match(/\d{2,5}?/)
[12]
```

## 正向肯定查找和正向否定查找
- x(?=y) 只有当 x 后面紧跟着 y 时，才匹配 x。
- x(?!y) 只有当 x 后面不是紧跟着 y 时，才匹配 x。
``` bash
const target = 'bg.png index.html app.js index.css test.png'
// 从以上字符串中找出以png结尾的文件名
// 不使用正向肯定查找
target.match(/\b(\w+).jpg/g)
// ["bg.png", "test.png"]

// 使用正向肯定查找
target.match(/\b(\w+)(?=.jpg)/g)
// ["bg", "test"]
```
- 注意：x(?=y)需要和非捕获分组(?:)区分开（写法很类似） 其次 x(?=y)最终匹配结果只有 x 没有 y

# 正则实例属性
- RegExp.prototype.global 是否开启全局匹配
- RegExp.prototype.ignoreCase 是否要忽略字符的大小写
- RegExp.prototype.lastIndex 下次匹配开始的字符串索引位置
- RegExp.prototype.multiline 是否开启多行模式匹配（影响 ^ 和 $ 的行为）
- RegExp.prototype.source 正则对象的源模式文本
- RegExp.prototype.sticky 是否开启粘滞匹配

# 正则实例方法

## test
- 语法：regObj.test(str) 对字符串执行搜索
- 返回值：布尔值。测试 str 中是否存在匹配 regObj 模式的字符串，存在返回 true，不存在返回 false

## exec
- 语法：regObj.exec(str)对字符串执行搜索
- 返回值：如果没有匹配的文本则返回 null，否则返回一个结果数组：
返回的数组：第一个元素与正则表达式相匹配的文本；第二个元素是与 RegExpObject 的第一个捕获组相匹配的文本（如果有的话）；第三个元素是与 RegExpObject 的第二个捕获组相匹配的文本（如果有的话），以此类推。

# 字符串实例方法
## search
- 语法：str.search(reg）找出首次匹配项的索引
- 返回值：返回匹配成功的第一个位置,如果没有任何匹配，则返回-1
``` bash
'abc'.search(/b/)
// 1
```
